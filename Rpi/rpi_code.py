# -*- coding: utf-8 -*-
"""RPI CODE.ipynb

Automatically generated by Colaboratory.

Original file is located at
   
"""

import time, requests
from threading import Thread
from pprint import pprint
import pandas as pd


#Simulating Data from the three sensors of 6 users
test_data = pd.read_csv('sampledata.csv')

class dataDistributor():
    """
    Instances of this class will act as sensors data distributor via their get... methods
    """
    def __init__(self,device_uid):
        self.uid = device_uid
        self.bar_col_index = f"UID{device_uid}_bar"
        self.temp_col_index = f"UID{device_uid}_temp"
        self.hr_col_index = f"UID{device_uid}_HR"
        self.bar_row = 0
        self.temp_row = 0
        self.hr_row = 0
        self.data = test_data
    
    #Read the current row value, then auto increment the row value
    def getTemp(self):
        result = self.data.loc[self.temp_row,self.temp_col_index]
        self.temp_row = self.temp_row +1 
        return result
    def getBars(self):
        result = self.data.loc[self.bar_row,self.bar_col_index]
        self.bar_row = self.bar_row +1 
        return result
    def getHeartRate(self):
        result = self.data.loc[self.hr_row,self.hr_col_index]
        self.hr_row = self.hr_row +1 
        return result
    
    

cache = {}
MIN_ALLOWABLE_BARS = 20
BETA = 0  #We calculate O2 Consumption Rate and estTimeRemain using exp weighted average

def processSensorData(device_uid,d):
    cur_temp = d.getTemp()
    cur_bars = d.getBars()
    cur_heartRate = d.getHeartRate()
    now = time.time()
    if cache.get(device_uid) == None:   #uninitialized cache case
        o2ConRate = 0
        estTimeRemain = 0
    else:
        #get previous bars (O2 pressure) and timestamp of last reading from cache
        prev_bars = cache.get(device_uid).get("bars")
        prev = cache.get(device_uid).get("timestamp")
        
        #also get estTimeRemain for EWA calculation
        prev_estTimeRemain = cache.get(device_uid).get("estTimeRemain")
        
        #O2 consumption rate = change in bars/ time elapsed
        o2ConRate = (prev_bars-cur_bars) / (now - prev)
        
        #EST = beta*historical value + (1-beta)* (remaining allowable pressure)/current rate of O2 consumption
        estTimeRemain = BETA*prev_estTimeRemain + (1-BETA)*( (cur_bars-MIN_ALLOWABLE_BARS)/o2ConRate )
    
    #casting our data to prevent Numpy data or any JSON non serializable data type
    data = {
        "_id":str(device_uid),
        "temp": float(cur_temp),
        "bars": float(cur_bars),
        "heartRate": float(cur_heartRate),
        "o2ConRate":float(o2ConRate),
        "estTimeRemain": float(estTimeRemain),
        "timestamp": now
    }
    cache[device_uid] = data          #push to cache
    return data

debugging_payload = {
        "_id":str(1),
        "temp": 1,
        "bars": 1,
        "heartRate": 1,
        "o2ConRate":1,
        "estTimeRemain": 1,
        "timestamp": 1
}

NUM_RPI = 6
NUM_JOBS_PER_RPI = 30
NUM_RPI_DEBUG = 1
NUM_JOBS_PER_RPI_DEBUG = 1

def sendDataToCloud(uid):
    #initiliaze an instance of the data distributor
    d = dataDistributor(uid)
    
    #this is the link we will post our json to
    flask_url = "https://python-flask-app-mxaye.mybluemix.net/updateDocument"
    
    #In the actual implementation, this should be an async wait for sensors to interrupt
    #This should be good enough for now.... 
    
    for _ in range (NUM_JOBS_PER_RPI+1):
      
      data = processSensorData(uid,d)  #get the data 
      pprint(data)                     #debugging to console
      x = requests.post(flask_url,json=data)         #HTTP POST to our target
      print(x.text)                    #always check response message
      time.sleep(10)                   #assume we only poll sensors once every 10s
      
def main():
    """"
    
    DEMO
    
    
    """
    for thread_id in range(1,NUM_RPI+1):
        t = Thread(target = sendDataToCloud, args = (thread_id,))
        t.start()
        time.sleep(3)
        

if __name__ == "__main__":
    main()
